大家好
本期视频是数据结构2
新增了两种树，通用的树(每个节点可以有任意多子节点)和二叉树(每个节点最多有两个字节点)
分别是MTNode和DTNode，不用纠结名字，暂时懒得改了
之前演示线性表、链表、栈、队列的时候是输出到控制台，每个节点(元素)间用逗号分隔
但是树就不行了，观察变量窗口也很不方便，一层一层打开，看每个节点的值，很不方便
因此基于win32应用程序做了个显示功能，比直接观察变量直观多了
当然，线性数据结构的显示方案也进行了更新
线性数据结构采用如图的蛇形顺序显示
win32程序设计先前视频有讲，这次不再赘述
下面看主要改动内容：
core.cpp:新增对WM_CREATE和WM_SIZE消息的响应，重写WM_PAINT和WM_LBUTTONDOWN消息的响应
OnCreate函数初始化app的rect和font成员，并调用外部的init函数，就是stdafx.cpp里面的测试用例初始化
OnSize更新app.rect，OnLButtonDown调用stdafx.cpp里面的test函数，触发测试用例的显示
OnPaint函数，以参数message的值分为0和1两个分支，0用于绘制传入wParam所指的对象，1用于擦除客户区(暂未使用)，而系统自动调用OnPaint函数时message将等于WM_PAINT，即15，不进行任何处理
这里wParam的原始类型为无符号整型，我们强制转化为GUIBase类型的指针使用，因为调用点完全清楚而且做了适当的保护，我们的所以绘制元素都定义在gui.cpp、gui.h,共有Line(直线)、Shape(矩形或椭圆)、Text(文本)、Button(按钮，Shape和Line的组合)四种，都继承自GUIBase
GUIBase定义了一个固定的数值成员，用于OnPaint函数里面校验传入参数wParam是否为有效的GUIBase类指针，纯虚函数Print,函数Refresh
这样如果将子类(Line、Shape、Text、Button)的对象指针转化为父类(GUIBase)指针在OnPaint函数中调用Print函数，将自动转调用该类自己定义的Print函数
两个数据类：Point和Rect，没什么可说的
Line类，数据成员有：第一个点pt1，第二个点pt2，颜色color，线宽lw，线型ls,实现虚函数Print，两种构造函数，一个求线长度的函数(未使用),和一堆设置属性的函数(访问器)
构造函数只需注意各成员初值，如线宽为1，线型为实线，颜色为黑色，无参构造函数和有参构造函数的pt1和pt2不一样
GetLength函数求两点距离的公式
访问器方法略过，只需要注意的是我们改变对象属性不立即重绘，需要手动调用基类的Refresh函数才行，这是考虑到可能先后设置多种属性，再一次性刷新，而不是设置一次刷新一次
主要看Print函数，根据ls、lw、color创建画笔，选择画笔并保存旧画笔，MoveToEx、LineTo绘制直线，恢复画笔
Shape类同理，构造函数只有rect不一样，其它成员分别为边框颜色(bColor)白色和填充颜色(fColor)黑色，线宽为1，类型为有边框有填充的矩形
GetWidth和GetHigh不必多说，访问器方法略过
Print函数稍微复杂，线判断是否有边框，无边框时初始化白色画笔，否则为bColor；再判断是否填充，无填充时初始化白色画刷，否则为fColor，然后加载画笔、画刷，最后根据是否为椭圆分别调用Ellipse或者Rectangle函数进行绘制；恢复画笔、画刷
Text类同上，构造函数区别仅在于文本显示位置(pt)，文本内容(str)、长度(len)、颜色(color)、对齐(ts)都相同
一堆访问器函数(包括GetLength)
Print函数，设置文本对齐方式、文本颜色，选择字体，输出文本，最后恢复对齐方式和颜色
Button类，包含一个Shape和Text对象，和一个未使用的成员multiline
Print函数只是对border和text的Print的转调用，只需注意先绘制矩形再绘制文本即可
绘制部分底层展示完毕，接下就是绘制方案了
BaseData类的Print函数稍作改动，之前是调用stdio的printf直接输出到控制台，这里根据var的值初始化一个Button，并输出到pc.left和pc.top处
我们把数据结构分为线性和树状，分别定义了LinearADT和TreeADT，都含有纯虚函数，因此都是虚基类
有各自的ResetPosition函数，TreeADT有额外的一个函数GetDepth，用于求树的深度
PrintCtrl类，数据成员有line1和几个整型变量，用在计算节点显示坐标的地方
GetCenter，0表示获取水平中心，1表示获取垂直中心，DrawLine绘制一条直线，LinearView为线性数据结构显示，TreeView为树形结构显示，Print的两个重载分别转调用这两个函数
DrawLine不必多说，设置line1并更新显示而已
LinearView函数，先显示第一个点，然后进入for循环(i从1开始)，用state区分3种绘制状态，dir区分生长方向
初始化为向右生长，如果即将抵达右边界，则向下移动，然后改变方向为向左生长
如果向左抵达左边界，则再向下移动，之后反向
现在数值、逻辑有点问题，懒得查了，显示没有问题就行
TreeView函数，输入一个节点指针src和一个显示区域矩形target
先在显示区域的中间显示根节点，再获取src的子节点个数，并在循环内绘制指向子节点的直线和子节点本身 ，而子节点还可能有子节点，形成递归
至于函数里用到的GetChildCnt函数、GetChild函数现在根本没有定义，但不必在意，继承自TreeView的类必须自行保证，实现所有的纯虚函数，包括这两个和GetChildData。同理，LinearView的子类需要自行实现[]的重载和GetLength函数
GetDepth函数也是一个递归，似乎是没问题的
DTNode和MTNode类都继承自TreeADT，并且实现了所有3个虚函数，因此可以实例化
线性表、链表、双链表则继承自LinearADT，实现两个虚函数，然后就可以正常使用并采用新的显示方案
最后给大家演示一下测试函数，reset函数重设显示区宽高
init函数初始化数据结构，test函数触发显示，所有的显示都是pc.Print(对象地址),PrintCtrl的Print有重载，将自动识别是线性数据结构还是树形数据结构
这是普通树，每个节点子节点 数量不固定
这是二叉树，每个节点子节点树不超过2
本期视频到此为止，溜了溜了
























































































