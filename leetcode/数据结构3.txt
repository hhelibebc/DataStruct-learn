大家好
本期视频是图数据结构
的显示方案
图算法还没搞懂，也还没整理代码
这次修改了gui.cpp、gui.h、core.cpp、map.h、map.cpp和stdafx.cpp
core.cpp把MyApp类font成员改为font1和font2，显示时发现最好有两种字号、字体，OnCreate函数初始化两种字体，font1为大号，font2为小号
gui.h新增了PenProp、BrushProp和TextProp三个类，分别为画笔、画刷、字体的属性
修改Line、Shape和Text的实现，之前关于显示效果选项的属性及其访问器都继承得来，同理，每个类的Print函数都做了少量修改
可以看到，Line类可以设置画笔属性，即线型、线宽、颜色
Shape类可以设置画笔和画刷的所有属性，额，也就是填充颜色，好像没有修改填充图案的必要
Text类可以设置文本属性，有对齐方式、颜色、字号，其中，在Text类的Print函数中根据BigFont选择app.font1或者app.font2
新增Curve类，用于绘制曲线，之前考虑到两个点见有回环想画成图上这种，但一切从简，就算了，统统采用直线
Button定义没改
新增Arrow类，绘制箭头，这箭头也是省略形式，演示一下
箭头就是从目标点，引出两条线段
这个有向带权图就是这个图
但曲线着实不好画，主要是曲线和椭圆的交点不怎么好求出
毕竟箭头的起始点需要交点坐标
如图所示，线段中间是路径的权值
用的是红色小号字体
Line类新增两个成员：angle和len，分别是直线与x轴夹角、线段长度
定义了一个私有的Init函数，供三个构造函数调用，进行共同的初始化
也就是把所有成员清零，包括基类PenProp的数据成员，再把线宽设为1
有参构造函数分别转调用重载的SetParam函数
第一个重载是两点确定一条直线，第二个重载是起点、角度、长度确定一条直线
准确来说是线段
类Arrow同理，有参构造函数转调用SetParam，也是输入两个点，mode即type，控制在哪个点绘制箭头
先求取两点确定的直线，然后从某点开始，画两条长15，与直线成15°夹角的线段即可
Shape没做太多改动，主要新增了GetCrossPoint函数，求直线与矩形/椭圆的交点
因为是任意直线和椭圆，所以没有太好的办法，直线的标准方程带入椭圆标准方程，代数求解，反映在程序就是135-165行的分支。代码不难，分支太多，最外层三个分支对应竖直直线、水平直线和任意直线，每个分支里面还要细分为与矩形交点还是与椭圆交点。甚至任意直线和椭圆交点还可以分为直线是否经过椭圆中心点的状况。毕竟如果直线通过椭圆交点的话，可以用直线角度带入椭圆参数方程求解
以上就是所有的绘图基础了
下面看图数据结构：
图有两种表示方法：邻接表和邻接矩阵，本程序采用了邻接矩阵法
一个简单的枚举和一个简单的结构体
Edge类，边，三个成员分别为pow(权值)，type(类型)，drew(是否已经绘制)
无参构造函数，直接采用初始化列表赋初值
Vertex类，顶点，包含一个data(数据成员)，prop(顶点属性)，暂时只用到x,y，图的拓扑相当复杂，就没办法自动排列、自动求取坐标显示，因此需要初始化时确定每个顶点的绘制坐标，SetLocation函数的功能就是这个
Map类，只有一个带初始化列表的无参构造函数，毕竟创建一个图是很麻烦的事情，不需要在构造函数完成
图初始化由Init完成，第一个重载为邻接矩阵方式初始化，第二个重载为邻接表方式初始化，BFS、DFS、DFS_Visit还没写，GetEdge和GetVertex顾名思义获取边和顶点，Print重写基类MapADT的虚函数
之前考虑可以做几种类型的图，有向or无向，带权or无权，邻接表or邻接矩阵，因此写了MapADT统一一下，顺便把图的显示也纳入PrintCtrl类控制
但后来发现，邻接表被pass掉，其它情况可以由Map一个类表示，加两个bool成员即可：directional和weighted
两个Init函数都调用CommonInit函数进行共同初始化，分配内存，保存参数
第一个重载，两层for循环，循环次数为vertex_cnt(顶点个数),外层循环保存顶点的位置信息，内层循环保存边的权值信息
这个图只有8个顶点，绘制位置由map_addr指定，权值由map_data指定，其中0表示未连接，如-4表示点0与点1连接，边权值为-4，5表示点2与点3相连，权值为5
这是个有向图，即 有0到1的边，但没有1到0的边，边是单向的
第二个重载，为邻接表方式初始化，把边的信息和顶点的信息一起传入，第一个for循环保存顶点信息，第二个for循环保存边的信息权值设为两顶点的距离
这个图就是无向带权图了，共有48个顶点，154条边，如果采用上一种方式初始化，则需要填写一个48*48的稀疏矩阵，2304个元素仅154个有值
当然，这两个数组也不是凭空捏造，万恶之源是这个：三国群英传1的地图
每个城为一个顶点，城之间的路径大致长这样，序号自己随便标的，标号序号之后，边的信息很容易得出，但顶点的坐标。。
就是一个个用画图测量得出，1：1还原，这就是地图数据了
是不是还挺像的
剩下的就只有Map类的Print函数了
首先，创建了一堆局部变量
绘制顶点直接调用BaseData的Print函数即可，唯一注意的是设置顶点颜色
初始化shape，然后绘制顶点间的连线(边)
两层for循环，获取每一条边，但无效的边(权值为0)或者已经绘制的边不再绘制
绘制过程如下：
先设置line的起止点为两个顶点的中心点
如果为有向图，且这两个顶点间有两条有效边，则绘制应分别上移和下移10个像素
然后求取line和两个顶点所在椭圆的交点，绘制两个交点的连线
如果有向，绘制箭头
如果带权，绘制权值，权值显示格式为小数点后1位，显示位置为连线中点处
有了这个图之后，就可以求点4到点42的最短路径了
当然，这是后话，本期视频就这些了























