最近确实有一些事，比较忙，而且暂时不知道做什么小游戏之类的了
加上需要补充知识，重拾数据结构
本期是其中最基本的内容：线性表、栈、队列、链表相关
后续会继续更新，用C++编写的，也可以用C实现，都没有问题的
写了几天了，就左边这些文件
初步估计500多行代码吧，下面看详细介绍
leetcode.cpp，项目名称，程序入口，暂时用作了这些数据结构的测试文件
本来打算做leetcode刷题视频的，后来想想先复习、学习一下数据结构再去
stdafx.h包含了常用的头文件，创建了BaseData类——以后所有数据结构的数据域
一个自制的宏，用于清空结构体变量或者类对象
BaseData暂时设有一个整型变量var和字符串指针str，但只用到了var，定义了Print函数，输出var和一个空格到控制台
list.h，包含了两个宏，LNode、DLNode、LinearList、LinkList、DLinkList五个类，前两个分别是单链表和双链表的节点，LNode只有一个指针域next，DLNode有两个指针front和next
这两个类作为数据类，就懒得管什么访问权限之类的了，也没有任何成员函数，可以用结构体替代(反正C++的结构体和类没什么区别)
线性表主要有Insert、Delete和Print三个函数，功能同字面意思，其它的都是一些辅助的函数，另外重载了[]运算符，可以把线性表对象当作数组使用，所有数据成员设为私有。Resize函数被设为私有，只在本类成员函数使用
LinkList和DLinkList类定义雷同，唯一区别在于节点类型LNode和DLNode。都有Print、Insert、Delete、Length函数，构造、析构函数、重载运算符[]；数据成员都是head、rear指针和长度len
list.cpp是对list.h的补充，实现还未实现的函数，实际上C++可以把所有内容全写在头文件
stack.h为栈(Stack类)的定义，Stack基于线性表实现，只要实现Push、Pop、Top、Print函数即可，底层完全借用LinearList
但栈不是一个线性表，因为它不能任意位置插入、删除，即不能有Insert、Delete方法，因此不能继承自LinearList，从定义也知道"栈 is a 线性表"不成立。但"栈 have a 线性表"是可以的，栈含有一个线性表、维护一个线性表data成员。设为私有是为了保证仅能通过类提供的方法访问、修改数据，方便后续定位问题
stack.cpp给出栈的操作方法的实现
queue.h给出了6种队列的类定义，其中前4种(基础队列、双向队列、循环队列、双向循环队列)都基于线性表实现，当然也是包含关系，毕竟它们也不是线性表，也不应该能随机访问；后两种(链队、双向链队)分别基于链表、双向链表实现
不管多么花里胡哨的队列，但它也只是个队列，必须实现的操作只有Push、Pop，双向队列新增rPush和rPop，链队突破了长度限制，动态分配内存，可以一直入队
Queue包含一个bool变量和一个线性表data,实现了基础队列的Push、Pop、Print函数和一些辅助函数
Deque继承自Queue，仅新增rPush和rPop两个方法，逻辑上Deque is a Queue也说得通
LoopQueue继承自Queue，但重新了几乎所有函数，新增两个数据成员head和rear,定义为Int是因为我们只需要知道其在线性表中的索引即可，这个继承只是为了使用线性表数据成员data
LoopDeque继承自LoopQueue，新增两个方法rPush和rPop
链队则因为数据成员的类型完全不同无法通过继承复用，尽管函数实现十分接近，代码上也是Copy、修改得到的
下面看leetcode.cpp,一个基础数据对象base1，栈s1，队列q1、q2、q3、q4、q5、q6，线性表L1，单链表L2，双链表L3
和它们的测试函数，及调用点
栈，压栈11次，每次压入的数据var等于i，弹出9次，后进先出，因此栈中最终剩下0 1
搞错了，先看线性表的吧
循环11次，每次在第0处插入元素，因此前11行为0-10的倒序
之后删除第4个元素(索引由0开始)，删除元素6，因此第12行没有6了
再删除第7个元素(2)，和第5个元素(4)，剩余10 9 8 7 5 3 1 0
打印第0、3、5个元素，分别是10 7 3，没有问题
具体实现见代码：
构造、析构不解释，Resize函数，assert断言newSize为非负数，如果为0等同于调用析构函数，否则用realloc调整内存块大小，如果调整成功，更新pBase和size，如果是缩小内存块，还需调整len的值
Insert函数，先使用assert检查输入参数，确保数据指针合法且索引有效
如果len==size，即线性表已满，需要先扩大内存块，如果idx<len，则插入之前需要将插入点右边的数据后移一个单位大小，再进行赋值，len累加，如果idx==len，即在线性表末尾追加，无需移动
Delete函数，先调用索引处数据的析构函数，将后续的数据前移，线性表末尾的数据清零，最后len自减
重载[]运算符，模拟数组操作
Print函数，打印整个线性表，并在末尾换行，便于演示、调试，所有的Print函数都是非必须的
我们返回去看Stack，全是对线性表成员函数的转调用，Push就是在末尾插入，Pop就是在末尾弹出，Top就是返回栈顶(线性表末尾的元素)，Print直接转调用
同样，Queue也是对线性表的转调用，Push在末尾插入，Pop从头部弹出
IsFull、IsEmpty等函数都是辅助性质的，很少直接使用，但也多少有点儿用，因此没设为私有，唯一值得注意的就是allowOverlap成员了，仅在Push的assert中使用，如果allowOverlap为真，则无论队列是否已满都会往下执行，进行插入操作，而底层的线性表是可以自动扩展的，因此队列长度不受限制
在构造函数初始化列表初始化为false，默认队列已满时不允许插入操作
前10次插入操作成功完成，但第11次时失败，队列已满
控制台显示，在queue.cpp第14行失败，就是这儿
同样，队列为空时也不允许弹出操作
插入15次(0-14)，弹出9次(0-8)，最终剩下9-14
Deque只增加了rPush函数和rPop函数，rPush在头部插入，rPop从尾部弹出
测试函数中，先从尾部插入11个元素(0-11)，再从头部插入7个元素(6-0)，然后从头部弹出9个元素(6-0,0,1)，最后从尾部弹出9个元素(2-10)
LoopQueue 则和Queue不太一样，它的数据范围不是整个线性表了，而是head和rear之间的元素，元素入队则rear后移，元素出队则head后移，如果越过边界则返回线性表开头
因为可以循环，所以队列的判满、判空和求长都与Queue大不相同，为了区分队列满和空的状态，我们少使用一个储存空间，如果head前面紧跟rear(或者说rear追上head的前一刻)，我们认为队列已满
allowOverlap的含义也与Queue有所区别，
看例子，入队15次，前9次(0-8)，最大长度为10，保留一个节点，则最大长度为9
第10次入队时队列已满，但allowOverlap为true，允许覆盖，则10成功入队，但最先入队的0被挤掉，后续5次入队同理，而接下来的9次出队则没有改变，只需注意head、rear的维护和元素热暂存、返回即可
Print函数稍作修改，不能直接使用线性表data的Print函数了。如果head<=rear，直接打印Head和rear之间的数据；否则分两段打印，先打印head到线性表末尾的元素，再打印开头到rear之间的元素
LoopDeque仅增加了rPush和rPop，没什么难点了
这测试函数输出结果显示程序没有问题，下一个
LinkList，构造、析构不解释，这里链表的头节点没用于存放数据，为什么定义了一个rear我也不知道，不过不要紧
这里也重载了[]运算符，方便使用，伪装成数组，但改变不了顺序访问的事实
Print函数，顺序访问每一个节点，打印其数据data即可，最后输出一个换行
Insert函数，先创建LNode节点，将传入的elem指向的数据提取出来保存
然后。。。进行节点的插入操作，先找到插入点的上一个元素，因为是单链表，所以需要找到上一个，然后上一个节点next指针指向新节点，新节点next指针指向插入点的元素，len自增
Delete函数，索引处元素，上一个元素next指针直接改指向下一个元素，释放此节点元素
DLinkList，构造、析构、Print函数差别不大，Insert函数和Delete函数只是多了对front指针的维护
而重载运算符[]函数，对idx是否过半进行了分类，如果没过半，则从头开始，往后查找，否则从尾部开始，从后往前查找
link_list_test，插入11次(10-0)，删除5次(7-3)
dlink_list_test，插入11次(10-0)，删除5次(8-4),最后输出索引为3 4 5 0的元素，分别为2 1 0 10
剩下的就只有链队和双向链队了，完全基于链表和双向链表，不想细说了，函数内部都是简单的转调用
链队对长度不限制，因此入队30次，出队15次也是可以的
双向链队的rPush和rPop也正常工作
本期就此结束，下期做树和森林什么的，各种树
拜拜




















