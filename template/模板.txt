大家好
本期是模板相关知识，我也是刚学、试用，不过感觉挺有意思的
代码量不多，就这5个文件
console.cpp主程序
template.cpp/template.h为一系列模板函数、偏特化版本
compiler.cpp/compiler.h用STL的系列工具实现了一个词法分析器
为编译器中最简单的第一个步骤，因此命名为compiler
先简单介绍模板，模板是template关键字引出的内容
包括模板参数、模板函数、模板类
可以理解为编译器重载
C++函数重载是发生在运行期的，运行时根据不同的函数签名(参数列表)确定调用不同的函数，但所有的重载都必须明确的写出
重载的一般要求是函数名相同，功能相似，也可以写完全不同的功能但命名为重名构成重载，但没有意义，只会造成调用者和自己的混乱
而模板参数允许我们将参数类型先用标识符替代
如int Compare(T src,T dest)函数，类型T尚未确定
但我们使用此类型的变量进行了同样的操作，并把这些操作合成一个与类型无关的函数Compare，所进行的操作为:如果src>dest，则返回1；如果src==dest，则函数返回0；否则返回-1
这里的>，==都不一定是关系运算符，因为T不一定是简单类型
如果T是类名，那Coder需要保证T类有定义重载运算符>和==，如果没有，则会报编译错误(不严谨)
因为模板不代表实际代码，为了实现对任意类型都有正常的函数调用，编译器会尝试对每一种调用形式的类型产生一份代码(实例化)
如果实例化时发现有复合类型T没有定义重载运算符>和==，则报编译错误
这个可以看作隐式接口。
正常的C、C++代码的函数声明就是显式接口，明确的指出了函数需要的形参、返回值；而这儿的约束条件由合法表达式给出，如果不满足将无法通过编译
int Compare(T* src,T* dest)与int Compare(T src,T dest)构成重载，虽然模板参数同样为T
后者接受所有的复合类型和基础变量类型
前者接受任意指针类型
没有更多信息的情况下，我们只能定义一个较为合理的比较规则memcmp逐字节比较
而int Compare(CPCHAR src,CPCHAR dest)则是一个完全确定的函数了，没有使用模板参数，作用就是按字典序比较字符串
CPCHAR 为 const char*
但似乎必须声明为前面Compare函数的偏特化版本，因此前面加了template<>
函数体定义在源文件，仅仅是转调用strcmp而已
如果把它声明为普通函数，那传参为(CPCHAR,CPCHAR)时编译器将不知道该调用Compare(T*,T*)还是Compare(CPCHAR,CPCHAR)
收回前言，定义成普通函数也没有问题
编译器会优先选择更明确的函数调用：无特化版本(普通函数)、偏特化版本、模板函数
这里定义了6种调用格式队友模板参数T类型分别为：CPCHAR,int,float,Complex,Complex(指针类型),float(指针类型)
第1个调用了偏特化/普通版本int Compare(CPCHAR,CPCHAR)
返回1说明前者大于后者，i在c后面，正确
第2、3个调用了int Compare(T,T)，都是简单变量类型，>和==为内置运算符i1=i2,f1<f2，正确
第4个也调用了int Compare(T,T)，但这里的T是复合类型Complex
而我已经给Complex定义了重载运算符>和==，因此这里的Compare输出/行为，取决于重载运算符>和==的实现(和<无关，因为Compare函数没用到<)
第5、6个调用了int Compare(T*,T*)版本，它们的Compare也没多少实际意义
这里还有一个模板函数Find，也是只有一个模板参数T，功能为在arr处开始长为cnt的T类型数组里面查找dest元素
如果查到存在则返回下标，否则返回-1
因为Compare已经是类型无关了，因此Find也是类型无关
但无论对什么类型，都有如下操作：
最多循环cnt次，比较dest和arr[i]，如果ret为0即为查询成功，返回i，如果ret为-1，表示dest<arr[i]，而数组是升序的，后续的数据都不小于arr[i]，没必要继续循环，直接返回-1
这里需要注意的是：如果T为复合类型，但由于arr为T*类型，因此arr[i]不存在问题，也不要求T实现重载运算符[]
这个Find函数在可以同时支持对字符串数组和数值数组的查询
当然也可以针对对象数组，那要求对象的类型支持Compare函数，即支持>和==
case下标为4，这儿因为symbols不是升序的，#小于+直接结束了，因此搜索不成功，而ints里面肯定是没有5的，因此搜索无果2，返回-1
虽然symbols搜索失败，但不是模板的问题，模板还是生效了的，所以问题不大
剩下的就是模板类了
如果有一系列的数据类型，有完全相同的方法、属性，仅仅是操作对象的类型不相同，这样就有必要定义模板类了
这样多种操作多种类型的一系列类可以简化为一个模板类
但也不要试图使用模板节省目标代码和二进制代码量，因为模板实例化时编译器会创建每一个模板参数类型的代码副本，目标代码和二进制代码都是多份，这样操作的优点仅为：让编译器帮我们处理了重复的工作，不易(不会)出错，源代码比较整洁(只有一份模板代码)
比如设计数据结构树、图时，一般的设计都是数据域和指针域分开，数据域单独设计为类，这样我们可以随意增删数据节点的成员、属性
但即使这样也不能实现同一份程序存在多种类型的数据节点的树
模板类可以做到
考虑到难度，我只实现了一个粗略的MyList类——一个泛型的线性表
应该是可以动态增长的，有BUG也实属正常
不考虑内存泄漏、覆盖什么的倒也能用，至少现在可以演示
这些成员函数的实现不是这里的重点，只是一个最简单的线性表而已
还做成了栈的形式，只对外提供了Push、Pop函数、构造析构函数、[]运算符
这里可以看到list1元素类型为Complex
list1经过2次Push，压入了元素c1和c2，符合预期
list2元素类型为int，压入i1之后，正确
list3元素类型为MyList<int>，每个元素占12个字节，3个成员分别为pData、size、capacity
list3经过5次Push，已经包含了5个int类型的MyList，似乎也没有问题
剩下的就只有compiler——的词法分析器了
主要内容就是WordWrap类,Wrap应该是有分割的意思，类的功能就是把一个代码文件分割成记号(Token)串，记录每个记号和其出现的次序
前面讲了那么多模板，实际又不可能自己写，直接用现成的STL就好了，自己也不可能写得有人家好
主要用到了CHAR_TYPE和TOKEN_TYPE两个枚举，Record结构体类型和WordWrap类
Record表示一种记号，由记号类型(TOKEN_TYPE type)和记号(string token)。其中string是基于模板写就的，超好用的字符串
WordWrap类同时用到了两种vector(STL提供的序列化容器，加强版数组),Record类型的tokens，和int类型的idxs，分别记录记号串列表和索引列表，total表示记号总数，也是idxs的元素个数，私有成员就是一个文件缓冲区，文件加载完成就没用了，仅用于Open函数
源文件主体为：变量定义，3个静态函数Exist、GetCharType和JoinIn,3个成员函数Open、GetToken和Classify(未开始)
Open函数就是读取指定文件的所有数据到calloc得到的内存空间，首地址记录在buf里
GetToken函数逐字节分析buf，即文件内容，划分记号串，记录出现次序其中调用了JoinIn函数
JoinIn函数，尝试将type类型的token加入ww.tokens里面，如果ww.tokens已经存在，则只在ww.idxs增加一项指向此处的索引
否则需要把token记录进ww.tokens，并在ww.idxs增加项
其中调用了find_if函数，用Exist的谓词判断tmpToken是否已经在ww.tokens存在,而Exist的比较规则就是采用之前定义的Compare函数的特化版本int Compare(CPCHAR,CPCHAR)
另外那些由ww.tokens和ww.idxs发起调用的函数都是vector类提供的，可以放心使用，功能自查，同字面意思
GetCharType根据输入的字符ch返回一个枚举类型，如果为0x00表示到达文件末尾，如果大于'~'表示非ascii码，可能是全角字符/汉字/其它字符集，或者是数字、字母、空白字符(空格、换行、制表)、符号(symbols定义的），如果都不满足也返回CHAR_NULL
剩下的就是一堆逻辑代码也，也不要问-2、-1、0什么的哪儿来的，调试出来的
主要对记号进行了如下分类：
单个符号：孤立的+-*/({[之类的
单行注释：由//引起直到第一个换行符，中间所有字符原封不动的记录下来
多行注释：由/*引起到*/结束，可跨越多行(多个换行符)
单个字符：由'引起到'结束，通常中间只有一个字符，如果有多个也正常记录，毕竟matlab语言是支持'gasghsd'的
字符串：由"引起到"结束，中间可以有任意多字符，也可以有不可见字符，其它字符集的字符
变量名/标识符：字母或下划线引起，非字母、数字、下划线结束，长度不限
数字：一个或多个十进制数字字符组成
十六进制数：0x或0X引起，后接一个或多个十六进制数字字符组成
浮点数：十进制浮点数，数字和.引起，非十进制数字字符结束
下面看演示：
Open函数执行后，buf已经有数据了，len为0xfd5
GetToken函数完成后，tokens、idxs和total都有更新
这次分析的是compiler.cpp文件
之前说错了，total表示tokens的元素个数，即是记号的种类，共0xc2种，记号的个数为0x410。可以看出，很多都是重复记号
先看idxs，前10项都是按顺序来的，表示前10项没有重复记号
再来看记号分类情况
第一个记号：单行注释
第二个记号：单行注释
第三个记号：单个符号 #
第四个记号：变量名 include
5:字符串 "compiler.h"
6:变量名 CPCHAR
这里CPCHAR是类型名，但这只是词法分析，我们无从得知这个记号是变量名还是类型名、函数名、关键字
7:变量名 keyword
8:单个符号 [
9:单个符号 ]
10:单个符号 =
11:单个符号 {
12:字符串 "asm"
13:单个符号 ,
14:字符串 "auto"
15也是单个符号, 但之前已经出现过，因此不会在auto后面增加第二条记录，而只是在idxs的0x0e处增加一条索引，指向tokens的0x0c项
即 ,
....接下来就是无限重复，自动分析的过程
到第0x6a项时出现了不一样的记号类型：十六进制数字
idxs里面第一个0x6a出现在0xc8处，表示此处之前已经有0xc7个记号了，但只有0x69种
下一种新类型应该是fseek(fi, 0, SEEK_END);中的0了，TOKEN_DIGIT,已经第0x1be个记号了
这个文件的最后两个记号无疑是 { 和 } 
但前面肯定早已存在，因此看idxs最后两项的索引，去tokens查询即可：0x0a { ,0x4b }
没有问题
通用程序似乎写好了自然要换个文件测试
其它就懒得看了，直接看最后几个记号吧
] 0x2b 正确
; 0x0a 正确
} 0x1f 正确
通过考验
本期视频结束，溜了溜了
















